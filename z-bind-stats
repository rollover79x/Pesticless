#!/usr/bin/python

import time
import sys
print >> sys.stderr, "Time, Sys {}".format(time.time())
import os
print >> sys.stderr, "OS {}".format(time.time())
import argparse
print >> sys.stderr, "Argparse {}".format(time.time())
import json

JSONFILE = '/tmp/bindstats.json'
CACHELIFE = 300

print >> sys.stderr, "JSON, Imports complete {}".format(time.time())

parser = argparse.ArgumentParser()
parser.add_argument("action", help="discoverzones | counter | zonecounter | zonemaintenancecounter | resolvercounter | socketcounter | incounter | outcounter")
parser.add_argument("-z", help="zone")
parser.add_argument("-c", help="counter name")
parser.add_argument("-p", help="bind stats port")
args = parser.parse_args()

# Configurable port
port = 8053
if args.p:
	port = args.p

# Read from the cache if it exists and is less than a minute old, so we don't hit Bind directly too often.
if os.path.exists(JSONFILE) and time.time() - os.path.getmtime(JSONFILE) <= CACHELIFE:
	print >> sys.stderr, "Cached {}".format(time.time())
	f = open(JSONFILE)
	j = json.load(f)
	f.close()
else:
	print >> sys.stderr, "Not cached {}".format(time.time())
	import httplib
	conn = httplib.HTTPConnection('localhost:{}'.format(port))
	conn.request('GET', '/')
	resp = conn.getresponse()
	if not resp.status == 200:
		print >> sys.stderr, "HTTP GET Failed"
		sys.exit(1)
	content = resp.read()
	conn.close()

	print >> sys.stderr, "Downloaded {}".format(time.time())

	import xml.etree.ElementTree as ET
	root = ET.fromstring(content)

	print >> sys.stderr, "XML Parsed {}".format(time.time())

	# Build the JSON cache
	j = {
			'zones': {},
			'counter': {},
			'zonemaintenancecounter': {},
			'resolvercounter': {},
			'socketcounter': {},
			'incounter': {},
			'outcounter': {},
			}
	for view in root.findall('./bind/statistics/views/view'):
		if view.findtext('./name') in ('_default',):
			for zone in view.findall('./zones/zone'):
				if zone.find('./counters') is not None:
					counters = {}
					for counter in zone.findall('./counters/*'):
						counters[counter.tag] = counter.text
					j['zones'][zone.findtext('./name')] = counters
	for stat in root.findall('./bind/statistics/server/nsstat'):
		j['counter'][stat.findtext('./name')] = stat.findtext('./counter')
	for stat in root.findall('./bind/statistics/server/zonestat'):
		j['zonemaintenancecounter'][stat.findtext('./name')] = stat.findtext('./counter')
	for view in root.findall('./bind/statistics/views/view'):
		if view.findtext('./name') in ('_default',):
			for stat in view.findall('./resstat'):
				j['resolvercounter'][stat.findtext('./name')] = stat.findtext('./counter')
	for stat in root.findall('./bind/statistics/server/sockstat'):
		j['socketcounter'][stat.findtext('./name')] = stat.findtext('./counter')
	for stat in root.findall('./bind/statistics/server/queries-in/rdtype'):
		j['incounter'][stat.findtext('./name')] = stat.findtext('./counter')
	for stat in root.findall('./bind/statistics/views/view/rdtype'):
		j['outcounter'][stat.findtext('./name')] = stat.findtext('./counter')

	print >> sys.stderr, "Parsed {}".format(time.time())

	f = open(JSONFILE, 'w')
	json.dump(j, f)
	f.close()

print >> sys.stderr, "Loaded {}".format(time.time())

if args.action == 'discoverzones':
	d = { 'data': [{'{#ZONE}': zone} for zone in j['zones'].keys()] }
	print json.dumps(d)
	print >> sys.stderr, "Done {}".format(time.time())
	sys.exit(0)

elif args.action == 'zonecounter':
	if not (args.z and args.c):
		print >> sys.stderr, "Missing argument"
		print "ZBX_NOTSUPPORTED"
		sys.exit(1)
	if j['zones'].has_key(args.z) and j['zones'][args.z].has_key(args.c):
		print j['zones'][args.z][args.c]
		print >> sys.stderr, "Done {}".format(time.time())
		sys.exit(0)
	else:
		print "ZBX_NOTSUPPORTED"
		sys.exit(1)

else:
	if not args.c:
		print >> sys.stderr, "Missing argument"
		print "ZBX_NOTSUPPORTED"
		sys.exit(1)
	if j[args.action].has_key(args.c):
		print j[args.action][args.c]
		print >> sys.stderr, "Done {}".format(time.time())
		sys.exit(0)
	else:
		print "ZBX_NOTSUPPORTED"
		sys.exit(1)
